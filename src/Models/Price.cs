// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Soenneker.Stripe.OpenApiClient.Models
{
    /// <summary>
    /// Prices define the unit cost, currency, and (optional) billing cycle for both recurring and one-time purchases of products.[Products](https://stripe.com/docs/api#products) help you track inventory or provisioning, and prices help you track payment terms. Different physical goods or levels of service should be represented by products, and pricing options should be represented by prices. This approach lets you change prices without having to change your provisioning scheme.For example, you might have a single &quot;gold&quot; product that has prices for $10/month, $100/year, and â‚¬9 once.Related guides: [Set up a subscription](https://stripe.com/docs/billing/subscriptions/set-up-subscription), [create an invoice](https://stripe.com/docs/billing/invoices/create), and more about [products and prices](https://stripe.com/docs/products-prices/overview).
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    public partial class Price : IAdditionalDataHolder, IParsable
    {
        /// <summary>Whether the price can be used for new purchases.</summary>
        public bool? Active { get; set; }
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>Describes how to compute the price per period. Either `per_unit` or `tiered`. `per_unit` indicates that the fixed amount (specified in `unit_amount` or `unit_amount_decimal`) will be charged per unit in `quantity` (for prices with `usage_type=licensed`), or per unit of total usage (for prices with `usage_type=metered`). `tiered` indicates that the unit pricing will be computed using a tiering strategy as defined using the `tiers` and `tiers_mode` attributes.</summary>
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_billing_scheme? BillingScheme { get; set; }
        /// <summary>Time at which the object was created. Measured in seconds since the Unix epoch.</summary>
        public int? Created { get; set; }
        /// <summary>Three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html), in lowercase. Must be a [supported currency](https://stripe.com/docs/currencies).</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Currency { get; set; }
#nullable restore
#else
        public string Currency { get; set; }
#endif
        /// <summary>Prices defined in each available currency option. Each key must be a three-letter [ISO currency code](https://www.iso.org/iso-4217-currency-codes.html) and a [supported currency](https://stripe.com/docs/currencies).</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_currency_options? CurrencyOptions { get; set; }
#nullable restore
#else
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_currency_options CurrencyOptions { get; set; }
#endif
        /// <summary>When set, provides configuration for the amount to be adjusted by the customer during Checkout Sessions and Payment Links.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Stripe.OpenApiClient.Models.Custom_unit_amount? CustomUnitAmount { get; set; }
#nullable restore
#else
        public global::Soenneker.Stripe.OpenApiClient.Models.Custom_unit_amount CustomUnitAmount { get; set; }
#endif
        /// <summary>Unique identifier for the object.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Id { get; set; }
#nullable restore
#else
        public string Id { get; set; }
#endif
        /// <summary>Has the value `true` if the object exists in live mode or the value `false` if the object exists in test mode.</summary>
        public bool? Livemode { get; set; }
        /// <summary>A lookup key used to retrieve prices dynamically from a static string. This may be up to 200 characters.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? LookupKey { get; set; }
#nullable restore
#else
        public string LookupKey { get; set; }
#endif
        /// <summary>Set of [key-value pairs](https://stripe.com/docs/api/metadata) that you can attach to an object. This can be useful for storing additional information about the object in a structured format.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_metadata? Metadata { get; set; }
#nullable restore
#else
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_metadata Metadata { get; set; }
#endif
        /// <summary>A brief description of the price, hidden from customers.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Nickname { get; set; }
#nullable restore
#else
        public string Nickname { get; set; }
#endif
        /// <summary>String representing the object&apos;s type. Objects of the same type share the same value.</summary>
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_object? Object { get; set; }
        /// <summary>The ID of the product this price is associated with.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Stripe.OpenApiClient.Models.Price.Price_product? Product { get; set; }
#nullable restore
#else
        public global::Soenneker.Stripe.OpenApiClient.Models.Price.Price_product Product { get; set; }
#endif
        /// <summary>The recurring components of a price such as `interval` and `usage_type`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Stripe.OpenApiClient.Models.Recurring? Recurring { get; set; }
#nullable restore
#else
        public global::Soenneker.Stripe.OpenApiClient.Models.Recurring Recurring { get; set; }
#endif
        /// <summary>Only required if a [default tax behavior](https://stripe.com/docs/tax/products-prices-tax-categories-tax-behavior#setting-a-default-tax-behavior-(recommended)) was not provided in the Stripe Tax settings. Specifies whether the price is considered inclusive of taxes or exclusive of taxes. One of `inclusive`, `exclusive`, or `unspecified`. Once specified as either `inclusive` or `exclusive`, it cannot be changed.</summary>
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_tax_behavior? TaxBehavior { get; set; }
        /// <summary>Each element represents a pricing tier. This parameter requires `billing_scheme` to be set to `tiered`. See also the documentation for `billing_scheme`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public List<global::Soenneker.Stripe.OpenApiClient.Models.Price_tier>? Tiers { get; set; }
#nullable restore
#else
        public List<global::Soenneker.Stripe.OpenApiClient.Models.Price_tier> Tiers { get; set; }
#endif
        /// <summary>Defines if the tiering price should be `graduated` or `volume` based. In `volume`-based tiering, the maximum quantity within a period determines the per unit price. In `graduated` tiering, pricing can change as the quantity grows.</summary>
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_tiers_mode? TiersMode { get; set; }
        /// <summary>Apply a transformation to the reported usage or set quantity before computing the amount billed. Cannot be combined with `tiers`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public global::Soenneker.Stripe.OpenApiClient.Models.Transform_quantity? TransformQuantity { get; set; }
#nullable restore
#else
        public global::Soenneker.Stripe.OpenApiClient.Models.Transform_quantity TransformQuantity { get; set; }
#endif
        /// <summary>One of `one_time` or `recurring` depending on whether the price is for a one-time purchase or a recurring (subscription) purchase.</summary>
        public global::Soenneker.Stripe.OpenApiClient.Models.Price_type? Type { get; set; }
        /// <summary>The unit amount in cents (or local equivalent) to be charged, represented as a whole integer if possible. Only set if `billing_scheme=per_unit`.</summary>
        public int? UnitAmount { get; set; }
        /// <summary>The unit amount in cents (or local equivalent) to be charged, represented as a decimal string with at most 12 decimal places. Only set if `billing_scheme=per_unit`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? UnitAmountDecimal { get; set; }
#nullable restore
#else
        public string UnitAmountDecimal { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Price"/> and sets the default values.
        /// </summary>
        public Price()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Price"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Soenneker.Stripe.OpenApiClient.Models.Price CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::Soenneker.Stripe.OpenApiClient.Models.Price();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "active", n => { Active = n.GetBoolValue(); } },
                { "billing_scheme", n => { BillingScheme = n.GetEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_billing_scheme>(); } },
                { "created", n => { Created = n.GetIntValue(); } },
                { "currency", n => { Currency = n.GetStringValue(); } },
                { "currency_options", n => { CurrencyOptions = n.GetObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_currency_options>(global::Soenneker.Stripe.OpenApiClient.Models.Price_currency_options.CreateFromDiscriminatorValue); } },
                { "custom_unit_amount", n => { CustomUnitAmount = n.GetObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Custom_unit_amount>(global::Soenneker.Stripe.OpenApiClient.Models.Custom_unit_amount.CreateFromDiscriminatorValue); } },
                { "id", n => { Id = n.GetStringValue(); } },
                { "livemode", n => { Livemode = n.GetBoolValue(); } },
                { "lookup_key", n => { LookupKey = n.GetStringValue(); } },
                { "metadata", n => { Metadata = n.GetObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_metadata>(global::Soenneker.Stripe.OpenApiClient.Models.Price_metadata.CreateFromDiscriminatorValue); } },
                { "nickname", n => { Nickname = n.GetStringValue(); } },
                { "object", n => { Object = n.GetEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_object>(); } },
                { "product", n => { Product = n.GetObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Price.Price_product>(global::Soenneker.Stripe.OpenApiClient.Models.Price.Price_product.CreateFromDiscriminatorValue); } },
                { "recurring", n => { Recurring = n.GetObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Recurring>(global::Soenneker.Stripe.OpenApiClient.Models.Recurring.CreateFromDiscriminatorValue); } },
                { "tax_behavior", n => { TaxBehavior = n.GetEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_tax_behavior>(); } },
                { "tiers", n => { Tiers = n.GetCollectionOfObjectValues<global::Soenneker.Stripe.OpenApiClient.Models.Price_tier>(global::Soenneker.Stripe.OpenApiClient.Models.Price_tier.CreateFromDiscriminatorValue)?.AsList(); } },
                { "tiers_mode", n => { TiersMode = n.GetEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_tiers_mode>(); } },
                { "transform_quantity", n => { TransformQuantity = n.GetObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Transform_quantity>(global::Soenneker.Stripe.OpenApiClient.Models.Transform_quantity.CreateFromDiscriminatorValue); } },
                { "type", n => { Type = n.GetEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_type>(); } },
                { "unit_amount", n => { UnitAmount = n.GetIntValue(); } },
                { "unit_amount_decimal", n => { UnitAmountDecimal = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteBoolValue("active", Active);
            writer.WriteEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_billing_scheme>("billing_scheme", BillingScheme);
            writer.WriteIntValue("created", Created);
            writer.WriteStringValue("currency", Currency);
            writer.WriteObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_currency_options>("currency_options", CurrencyOptions);
            writer.WriteObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Custom_unit_amount>("custom_unit_amount", CustomUnitAmount);
            writer.WriteStringValue("id", Id);
            writer.WriteBoolValue("livemode", Livemode);
            writer.WriteStringValue("lookup_key", LookupKey);
            writer.WriteObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_metadata>("metadata", Metadata);
            writer.WriteStringValue("nickname", Nickname);
            writer.WriteEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_object>("object", Object);
            writer.WriteObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Price.Price_product>("product", Product);
            writer.WriteObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Recurring>("recurring", Recurring);
            writer.WriteEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_tax_behavior>("tax_behavior", TaxBehavior);
            writer.WriteCollectionOfObjectValues<global::Soenneker.Stripe.OpenApiClient.Models.Price_tier>("tiers", Tiers);
            writer.WriteEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_tiers_mode>("tiers_mode", TiersMode);
            writer.WriteObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Transform_quantity>("transform_quantity", TransformQuantity);
            writer.WriteEnumValue<global::Soenneker.Stripe.OpenApiClient.Models.Price_type>("type", Type);
            writer.WriteIntValue("unit_amount", UnitAmount);
            writer.WriteStringValue("unit_amount_decimal", UnitAmountDecimal);
            writer.WriteAdditionalData(AdditionalData);
        }
        /// <summary>
        /// Composed type wrapper for classes <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Deleted_product"/>, <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Product"/>, <see cref="string"/>
        /// </summary>
        [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
        public partial class Price_product : IComposedTypeWrapper, IParsable
        {
            /// <summary>Composed type representation for type <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Deleted_product"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Soenneker.Stripe.OpenApiClient.Models.Deleted_product? DeletedProduct { get; set; }
#nullable restore
#else
            public global::Soenneker.Stripe.OpenApiClient.Models.Deleted_product DeletedProduct { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Product"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public global::Soenneker.Stripe.OpenApiClient.Models.Product? Product { get; set; }
#nullable restore
#else
            public global::Soenneker.Stripe.OpenApiClient.Models.Product Product { get; set; }
#endif
            /// <summary>Composed type representation for type <see cref="string"/></summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
            public string? String { get; set; }
#nullable restore
#else
            public string String { get; set; }
#endif
            /// <summary>
            /// Creates a new instance of the appropriate class based on discriminator value
            /// </summary>
            /// <returns>A <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Price.Price_product"/></returns>
            /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
            public static global::Soenneker.Stripe.OpenApiClient.Models.Price.Price_product CreateFromDiscriminatorValue(IParseNode parseNode)
            {
                _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
                var result = new global::Soenneker.Stripe.OpenApiClient.Models.Price.Price_product();
                if(parseNode.GetStringValue() is string stringValue)
                {
                    result.String = stringValue;
                }
                else {
                    result.DeletedProduct = new global::Soenneker.Stripe.OpenApiClient.Models.Deleted_product();
                    result.Product = new global::Soenneker.Stripe.OpenApiClient.Models.Product();
                }
                return result;
            }
            /// <summary>
            /// The deserialization information for the current model
            /// </summary>
            /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
            public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
            {
                if(DeletedProduct != null || Product != null)
                {
                    return ParseNodeHelper.MergeDeserializersForIntersectionWrapper(DeletedProduct, Product);
                }
                return new Dictionary<string, Action<IParseNode>>();
            }
            /// <summary>
            /// Serializes information the current object
            /// </summary>
            /// <param name="writer">Serialization writer to use to serialize this model</param>
            public virtual void Serialize(ISerializationWriter writer)
            {
                _ = writer ?? throw new ArgumentNullException(nameof(writer));
                if(String != null)
                {
                    writer.WriteStringValue(null, String);
                }
                else {
                    writer.WriteObjectValue<global::Soenneker.Stripe.OpenApiClient.Models.Deleted_product>(null, DeletedProduct, Product);
                }
            }
        }
    }
}
#pragma warning restore CS0618
