// <auto-generated/>
#pragma warning disable CS0618
using Microsoft.Kiota.Abstractions.Extensions;
using Microsoft.Kiota.Abstractions.Serialization;
using System.Collections.Generic;
using System.IO;
using System;
namespace Soenneker.Stripe.OpenApiClient.Models
{
    [global::System.CodeDom.Compiler.GeneratedCode("Kiota", "1.0.0")]
    #pragma warning disable CS1591
    public partial class Source_receiver_flow : IAdditionalDataHolder, IParsable
    #pragma warning restore CS1591
    {
        /// <summary>Stores additional data not described in the OpenAPI description found when deserializing. Can be used for serialization as well.</summary>
        public IDictionary<string, object> AdditionalData { get; set; }
        /// <summary>The address of the receiver source. This is the value that should be communicated to the customer to send their funds to.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? Address { get; set; }
#nullable restore
#else
        public string Address { get; set; }
#endif
        /// <summary>The total amount that was moved to your balance. This is almost always equal to the amount charged. In rare cases when customers deposit excess funds and we are unable to refund those, those funds get moved to your balance and show up in amount_charged as well. The amount charged is expressed in the source&apos;s currency.</summary>
        public int? AmountCharged { get; set; }
        /// <summary>The total amount received by the receiver source. `amount_received = amount_returned + amount_charged` should be true for consumed sources unless customers deposit excess funds. The amount received is expressed in the source&apos;s currency.</summary>
        public int? AmountReceived { get; set; }
        /// <summary>The total amount that was returned to the customer. The amount returned is expressed in the source&apos;s currency.</summary>
        public int? AmountReturned { get; set; }
        /// <summary>Type of refund attribute method, one of `email`, `manual`, or `none`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? RefundAttributesMethod { get; set; }
#nullable restore
#else
        public string RefundAttributesMethod { get; set; }
#endif
        /// <summary>Type of refund attribute status, one of `missing`, `requested`, or `available`.</summary>
#if NETSTANDARD2_1_OR_GREATER || NETCOREAPP3_1_OR_GREATER
#nullable enable
        public string? RefundAttributesStatus { get; set; }
#nullable restore
#else
        public string RefundAttributesStatus { get; set; }
#endif
        /// <summary>
        /// Instantiates a new <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Source_receiver_flow"/> and sets the default values.
        /// </summary>
        public Source_receiver_flow()
        {
            AdditionalData = new Dictionary<string, object>();
        }
        /// <summary>
        /// Creates a new instance of the appropriate class based on discriminator value
        /// </summary>
        /// <returns>A <see cref="global::Soenneker.Stripe.OpenApiClient.Models.Source_receiver_flow"/></returns>
        /// <param name="parseNode">The parse node to use to read the discriminator value and create the object</param>
        public static global::Soenneker.Stripe.OpenApiClient.Models.Source_receiver_flow CreateFromDiscriminatorValue(IParseNode parseNode)
        {
            _ = parseNode ?? throw new ArgumentNullException(nameof(parseNode));
            return new global::Soenneker.Stripe.OpenApiClient.Models.Source_receiver_flow();
        }
        /// <summary>
        /// The deserialization information for the current model
        /// </summary>
        /// <returns>A IDictionary&lt;string, Action&lt;IParseNode&gt;&gt;</returns>
        public virtual IDictionary<string, Action<IParseNode>> GetFieldDeserializers()
        {
            return new Dictionary<string, Action<IParseNode>>
            {
                { "address", n => { Address = n.GetStringValue(); } },
                { "amount_charged", n => { AmountCharged = n.GetIntValue(); } },
                { "amount_received", n => { AmountReceived = n.GetIntValue(); } },
                { "amount_returned", n => { AmountReturned = n.GetIntValue(); } },
                { "refund_attributes_method", n => { RefundAttributesMethod = n.GetStringValue(); } },
                { "refund_attributes_status", n => { RefundAttributesStatus = n.GetStringValue(); } },
            };
        }
        /// <summary>
        /// Serializes information the current object
        /// </summary>
        /// <param name="writer">Serialization writer to use to serialize this model</param>
        public virtual void Serialize(ISerializationWriter writer)
        {
            _ = writer ?? throw new ArgumentNullException(nameof(writer));
            writer.WriteStringValue("address", Address);
            writer.WriteIntValue("amount_charged", AmountCharged);
            writer.WriteIntValue("amount_received", AmountReceived);
            writer.WriteIntValue("amount_returned", AmountReturned);
            writer.WriteStringValue("refund_attributes_method", RefundAttributesMethod);
            writer.WriteStringValue("refund_attributes_status", RefundAttributesStatus);
            writer.WriteAdditionalData(AdditionalData);
        }
    }
}
#pragma warning restore CS0618
